\section{Mathematics}

\subsection{Basic Math Operations}
\begin{lstlisting}
import math

# Common functions
math.ceil(x), math.floor(x)
math.gcd(a, b)      # Greatest common divisor
math.lcm(a, b)      # Python 3.9+
math.sqrt(x)
math.log(x), math.log2(x), math.log10(x)

# Powers
x ** y
pow(x, y, mod)  # (x^y) % mod - efficient modular exp

# Infinity
float('inf'), float('-inf')

# Custom GCD using Euclidean algorithm - O(log min(a,b))
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)
\end{lstlisting}

\subsection{Combinatorics}
\textbf{Description:} Compute combinations and permutations. For modular arithmetic, compute factorial arrays and use modular inverse.

\begin{lstlisting}
from math import factorial, comb, perm

# nCr (combinations) - "n choose r"
comb(n, r)  # Built-in Python 3.8+

# nPr (permutations)
perm(n, r)  # Built-in Python 3.8+

# Manual nCr implementation
def ncr(n, r):
    if r > n: return 0
    r = min(r, n - r)  # Optimization: C(n,r) = C(n,n-r)
    num = den = 1
    for i in range(r):
        num *= (n - i)
        den *= (i + 1)
    return num // den

# Precompute factorials with modulo
MOD = 10**9 + 7
def modfact(n):
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i-1] * i % MOD
    return fact

# Modular combination using precomputed factorials
# First precompute inverse factorials
def compute_inv_factorials(n, mod):
    fact = modfact(n)
    inv_fact = [1] * (n + 1)
    inv_fact[n] = pow(fact[n], mod - 2, mod)
    for i in range(n - 1, -1, -1):
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod
    return fact, inv_fact

def modcomb(n, r, fact, inv_fact, mod):
    if r > n or r < 0: return 0
    return fact[n] * inv_fact[r] % mod * inv_fact[n-r] % mod
\end{lstlisting}
