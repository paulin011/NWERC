\section{Advanced Data Structures}

\subsection{Segment Tree}
\textbf{Description:} Supports range queries and point updates in O(log n). Can be modified for range updates with lazy propagation.

\begin{lstlisting}
class SegmentTree:
    def __init__(self, arr):
        self.n = len(arr)
        # Tree size: 4n is safe upper bound
        self.tree = [0] * (4 * self.n)
        self.build(arr, 0, 0, self.n - 1)
    
    def build(self, arr, node, start, end):
        if start == end:
            # Leaf node
            self.tree[node] = arr[start]
        else:
            mid = (start + end) // 2
            # Build left and right subtrees
            self.build(arr, 2*node+1, start, mid)
            self.build(arr, 2*node+2, mid+1, end)
            # Combine results (sum in this case)
            self.tree[node] = (self.tree[2*node+1] + 
                              self.tree[2*node+2])
    
    def update(self, node, start, end, idx, val):
        if start == end:
            # Leaf node - update value
            self.tree[node] = val
        else:
            mid = (start + end) // 2
            if idx <= mid:
                # Update left subtree
                self.update(2*node+1, start, mid, idx, val)
            else:
                # Update right subtree
                self.update(2*node+2, mid+1, end, idx, val)
            # Recompute parent
            self.tree[node] = (self.tree[2*node+1] + 
                              self.tree[2*node+2])
    
    def query(self, node, start, end, l, r):
        # No overlap
        if r < start or end < l:
            return 0
        
        # Complete overlap
        if l <= start and end <= r:
            return self.tree[node]
        
        # Partial overlap
        mid = (start + end) // 2
        left_sum = self.query(2*node+1, start, mid, l, r)
        right_sum = self.query(2*node+2, mid+1, end, l, r)
        return left_sum + right_sum
    
    # Public interface
    def update_val(self, idx, val):
        self.update(0, 0, self.n-1, idx, val)
    
    def range_sum(self, l, r):
        return self.query(0, 0, self.n-1, l, r)
\end{lstlisting}

\subsection{Fenwick Tree (Binary Indexed Tree)}
\textbf{Description:} Simpler than segment tree, supports prefix sum and point updates in O(log n). More space efficient.

\begin{lstlisting}
class FenwickTree:
    def __init__(self, n):
        self.n = n
        # 1-indexed for easier implementation
        self.tree = [0] * (n + 1)
    
    def update(self, i, delta):
        # Add delta to position i (1-indexed)
        while i <= self.n:
            self.tree[i] += delta
            # Move to next node: add LSB
            i += i & (-i)
    
    def query(self, i):
        # Get prefix sum up to i (1-indexed)
        s = 0
        while i > 0:
            s += self.tree[i]
            # Move to parent: remove LSB
            i -= i & (-i)
        return s
    
    def range_query(self, l, r):
        # Sum from l to r (1-indexed)
        return self.query(r) - self.query(l - 1)

# Usage example
bit = FenwickTree(n)
for i, val in enumerate(arr, 1):
    bit.update(i, val)

# Range sum [l, r] (1-indexed)
result = bit.range_query(l, r)
\end{lstlisting}

\subsection{Trie (Prefix Tree)}
\textbf{Description:} Tree for storing strings, enables fast prefix searches. Time: O(m) for operations where m is string length.

\begin{lstlisting}
class TrieNode:
    def __init__(self):
        self.children = {}  # char -> TrieNode
        self.is_end = False  # End of word marker

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        # Insert word - O(len(word))
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word):
        # Exact word search - O(len(word))
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end
    
    def starts_with(self, prefix):
        # Prefix search - O(len(prefix))
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
    
    # Find all words with given prefix
    def words_with_prefix(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return []
            node = node.children[char]
        
        # DFS to collect all words
        words = []
        def dfs(n, path):
            if n.is_end:
                words.append(prefix + path)
            for char, child in n.children.items():
                dfs(child, path + char)
        
        dfs(node, "")
        return words
\end{lstlisting}

\subsection{Treap (Randomized Balanced BST)}
\textbf{Description:} Ordered set/map with expected O(log n) insert, erase, search, k-th, and rank. Combines a BST by key and a heap by random priority. Stores unique keys; for multiset, store (key, uid) or maintain a count.

\begin{lstlisting}
import random

class TreapNode:
    __slots__ = ("key", "prio", "left", "right", "size")
    def __init__(self, key):
        self.key = key
        self.prio = random.randint(1, 1 << 30)
        self.left = None
        self.right = None
        self.size = 1

def _sz(t):
    return t.size if t else 0

def _upd(t):
    if t:
        t.size = 1 + _sz(t.left) + _sz(t.right)

def _merge(a, b):
    # assumes all keys in a < all keys in b
    if not a or not b:
        return a or b
    if a.prio > b.prio:
        a.right = _merge(a.right, b)
        _upd(a)
        return a
    else:
        b.left = _merge(a, b.left)
        _upd(b)
        return b

def _split(t, key):
    # returns (l, r): l has keys < key, r has keys >= key
    if not t:
        return (None, None)
    if key <= t.key:
        l, t.left = _split(t.left, key)
        _upd(t)
        return (l, t)
    else:
        t.right, r = _split(t.right, key)
        _upd(t)
        return (t, r)

def _erase(t, key):
    if not t:
        return None
    if key == t.key:
        return _merge(t.left, t.right)
    if key < t.key:
        t.left = _erase(t.left, key)
    else:
        t.right = _erase(t.right, key)
    _upd(t)
    return t

class Treap:
    def __init__(self):
        self.root = None

    def __len__(self):
        return _sz(self.root)

    def contains(self, key):
        t = self.root
        while t:
            if key == t.key:
                return True
            t = t.left if key < t.key else t.right
        return False

    def insert(self, key):
        if self.contains(key):
            return
        node = TreapNode(key)
        l, r = _split(self.root, key)
        self.root = _merge(_merge(l, node), r)

    def remove(self, key):
        self.root = _erase(self.root, key)

    def kth_smallest(self, k):
        # 0-indexed k
        t = self.root
        while t:
            ls = _sz(t.left)
            if k < ls:
                t = t.left
            elif k == ls:
                return t.key
            else:
                k -= ls + 1
                t = t.right
        return None  # k out of range

    def count_less_than(self, key):
        # number of keys < key
        t, cnt = self.root, 0
        while t:
            if key <= t.key:
                t = t.left
            else:
                cnt += 1 + _sz(t.left)
                t = t.right
        return cnt

    def lower_bound(self, key):
        # smallest key >= key; returns None if none
        t, ans = self.root, None
        while t:
            if t.key >= key:
                ans = t.key
                t = t.left
            else:
                t = t.right
        return ans

# Usage example
T = Treap()
for x in [5, 1, 7, 3]:
    T.insert(x)
T.contains(3)           # True
T.kth_smallest(1)       # 3  (0-indexed)
T.count_less_than(6)    # 3  (1,3,5)
T.remove(5)
len(T)                  # 3
\end{lstlisting}
