\section{Advanced Python Syntax}

\textbf{Description:} Beyond basic loops - powerful Python constructs for competitive programming.

\subsection{List Comprehensions and Generators}

\begin{lstlisting}
# Basic list comprehension
squares = [x**2 for x in range(10)]
evens = [x for x in range(20) if x % 2 == 0]

# Nested comprehensions
matrix = [[i*j for j in range(5)] for i in range(3)]
flattened = [x for row in matrix for x in row]

# Dictionary comprehensions
char_count = {char: text.count(char) for char in set(text)}
squares_dict = {x: x**2 for x in range(5)}

# Set comprehensions
unique_lengths = {len(word) for word in words}

# Generator expressions (memory efficient)
sum_squares = sum(x**2 for x in range(1000000))
any_even = any(x % 2 == 0 for x in numbers)

# Conditional expressions in comprehensions
processed = [x if x > 0 else 0 for x in numbers]
filtered = [x for x in numbers if x > 0 and x < 100]
\end{lstlisting}

\subsection{Advanced Iteration Patterns}

\begin{lstlisting}
# Zip - parallel iteration
names = ['Alice', 'Bob', 'Charlie']
scores = [85, 92, 78]
for name, score in zip(names, scores):
    print(f"{name}: {score}")

# Enumerate with custom start
for i, item in enumerate(items, 1):  # Start from 1
    print(f"Item {i}: {item}")

# Zip longest (from itertools)
from itertools import zip_longest
for a, b in zip_longest(list1, list2, fillvalue=0):
    # Continues until longest list is exhausted

# Unpacking with star operator
first, *middle, last = [1, 2, 3, 4, 5]
# first=1, middle=[2,3,4], last=5

# Multiple assignment
a, b = b, a  # Swap variables
x, y, z = input().split()  # Parse multiple inputs

# Walking with indices and slicing
for i in range(len(arr) - 1):
    current, next_item = arr[i], arr[i + 1]

# Sliding window with enumerate
for i, val in enumerate(arr[:-k+1]):
    window = arr[i:i+k]  # k-length sliding window
\end{lstlisting}

\subsection{Advanced Data Structure Operations}

\begin{lstlisting}
# Dictionary operations
from collections import defaultdict, Counter

# DefaultDict with different types
adj_list = defaultdict(list)  # Adjacency list
counts = defaultdict(int)     # Frequency counter
groups = defaultdict(set)     # Group sets

# Counter - frequency counting
text = "hello world"
freq = Counter(text)
print(freq['l'])  # 3
most_common = freq.most_common(3)  # Top 3 frequent

# Dictionary merging (Python 3.9+)
dict1 = {'a': 1, 'b': 2}
dict2 = {'c': 3, 'd': 4}
merged = dict1 | dict2

# Dictionary comprehension with conditions
filtered_dict = {k: v for k, v in original.items() if v > 0}

# Nested dictionary access
from collections import defaultdict
nested = defaultdict(lambda: defaultdict(int))
nested[key1][key2] += 1

# Set operations
set1 & set2  # Intersection
set1 | set2  # Union
set1 - set2  # Difference
set1 ^ set2  # Symmetric difference

# List slicing tricks
arr[::-1]        # Reverse
arr[::2]         # Every 2nd element
arr[1::2]        # Every 2nd starting from index 1
arr[-3:]         # Last 3 elements
arr[:-2]         # All except last 2
\end{lstlisting}

\subsection{Functional Programming Features}

\begin{lstlisting}
# Map, filter, reduce
numbers = [1, 2, 3, 4, 5]

# Map - apply function to each element
doubled = list(map(lambda x: x * 2, numbers))
strings = list(map(str, numbers))

# Filter - select elements meeting condition
evens = list(filter(lambda x: x % 2 == 0, numbers))

# Reduce - accumulate values (from functools)
from functools import reduce
product = reduce(lambda x, y: x * y, numbers)
max_val = reduce(max, numbers)

# Lambda functions for sorting
points = [(1, 3), (2, 1), (0, 5)]
sorted_by_y = sorted(points, key=lambda p: p[1])
sorted_by_dist = sorted(points, key=lambda p: p[0]**2 + p[1]**2)

# Multiple sort keys
students = [('Alice', 85, 'A'), ('Bob', 92, 'B'), ('Charlie', 85, 'A')]
# Sort by grade (desc), then score (desc), then name (asc)
sorted_students = sorted(students, 
                        key=lambda x: (-ord(x[2]), -x[1], x[0]))
\end{lstlisting}

\subsection{Advanced String Operations}

\begin{lstlisting}
# String formatting
name, score = "Alice", 95
formatted = f"{name} scored {score:>5} points"  # Right align
binary = f"{42:08b}"   # 00101010 (8-digit binary)
hex_val = f"{255:02x}" # ff (2-digit hex)

# String methods for parsing
text = "  hello,world  "
words = text.strip().split(',')
joined = ' | '.join(words)

# String manipulation
s = "programming"
s.startswith("prog")    # True
s.endswith("ming")      # True
s.find("gram")          # 3 (index, -1 if not found)
s.replace("ram", "ROM") # "progROMMing"

# Character operations
char = 'A'
ord(char) - ord('A')    # 0 (offset from 'A')
chr(ord('a') + 1)       # 'b'

# Regular expressions (when needed)
import re
pattern = r'\d+'  # One or more digits
matches = re.findall(pattern, "abc123def456")  # ['123', '456']
\end{lstlisting}

\subsection{Control Flow and Error Handling}

\begin{lstlisting}
# Try-except for parsing
def safe_int(s):
    try:
        return int(s)
    except ValueError:
        return 0

# Else clause with loops
for item in items:
    if condition(item):
        break
else:
    # Executed if loop completed without break
    print("No item found")

# While-else similar pattern
while condition:
    if found:
        break
else:
    print("Condition became false, not broken")

# Ternary operator (conditional expression)
result = "positive" if x > 0 else "non-positive"
max_val = a if a > b else b

# Chained comparisons
if 0 <= x < len(arr):  # Bounds check
if a < b < c:          # Three-way comparison

# Walrus operator (Python 3.8+) - assignment in expression
while (line := input()) != "END":
    process(line)

if (n := len(items)) > 10:
    print(f"Many items: {n}")
\end{lstlisting}

\subsection{Advanced Input/Output Patterns}

\begin{lstlisting}
# Multiple assignment from input
a, b, c = map(int, input().split())
arr = list(map(int, input().split()))

# Reading matrix
n, m = map(int, input().split())
matrix = []
for _ in range(n):
    row = list(map(int, input().split()))
    matrix.append(row)

# Or with comprehension
matrix = [list(map(int, input().split())) for _ in range(n)]

# Reading until EOF
import sys
lines = sys.stdin.read().strip().split('\n')

# Fast I/O for large inputs
import sys
input = sys.stdin.readline
print = sys.stdout.write  # Only for string output

# Multiple test cases pattern
t = int(input())
for _ in range(t):
    # Process each test case
    pass

# Output formatting
print(*arr)              # Space-separated
print(*arr, sep='\n')    # Newline-separated
print(f"{x:.6f}")        # 6 decimal places
\end{lstlisting}

\subsection{Type conversions and casting}

\begin{lstlisting}
# Common conversions
s = str(123)         # '123'
i = int('42')       # 42
f = float('3.14')   # 3.14
b = bool(0)         # False

# Container conversions
lst = list((1,2))   # [1,2]
tup = tuple([1,2])  # (1,2)
st = set([1,2,2])   # {1,2}
d = dict([('a',1), ('b',2)]) # {'a':1, 'b':2}

# Characters and bytes
c = chr(65)         # 'A'
o = ord('A')        # 65
by = bytes('abc', 'utf-8')  # b'abc'
s2 = by.decode('utf-8')     # 'abc'

# Number formatting to hex/bin/oct
h = hex(255)        # '0xff'
bstr = bin(10)      # '0b1010'
octr = oct(8)       # '0o10'
# Formatting without prefixes
h2 = format(255, 'x')  # 'ff'
b2 = format(10, 'b')   # '1010'

# Safe literal evaluation (use instead of eval when parsing literals)
import ast
data = ast.literal_eval("[1, 2, {'a':3}]")

# Common contest patterns
# Convert split input to ints
arr = list(map(int, input().split()))
# Join values back into a string
s = ' '.join(map(str, arr))
\end{lstlisting}

\textbf{Key Benefits:}
\begin{itemize}
\item \textbf{Readability:} More concise and expressive code
\item \textbf{Performance:} Built-in functions are often faster than manual loops
\item \textbf{Memory:} Generators save memory for large datasets
\item \textbf{Debugging:} Functional style often easier to debug
\item \textbf{Contest speed:} Write solutions faster with fewer lines
\end{itemize}
