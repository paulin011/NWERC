\section{Computational Geometry}

\subsection{Basic Geometry}
\textbf{Description:} Fundamental geometric operations for 2D points.

\begin{lstlisting}
import math

# Point operations
def dist(p1, p2):
    # Euclidean distance
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def cross_product(O, A, B):
    # Cross product of vectors OA and OB
    # Positive: counter-clockwise
    # Negative: clockwise
    # Zero: collinear
    return (A[0] - O[0]) * (B[1] - O[1]) - \
           (A[1] - O[1]) * (B[0] - O[0])

def dot_product(A, B, C, D):
    # Dot product of vectors AB and CD
    return (B[0] - A[0]) * (D[0] - C[0]) + \
           (B[1] - A[1]) * (D[1] - C[1])

# Check if point is on segment
def on_segment(p, q, r):
    # Check if q lies on segment pr
    return (q[0] <= max(p[0], r[0]) and 
            q[0] >= min(p[0], r[0]) and
            q[1] <= max(p[1], r[1]) and 
            q[1] >= min(p[1], r[1]))

# Segment intersection
def segments_intersect(p1, q1, p2, q2):
    o1 = cross_product(p1, q1, p2)
    o2 = cross_product(p1, q1, q2)
    o3 = cross_product(p2, q2, p1)
    o4 = cross_product(p2, q2, q1)
    
    # General case
    if o1 * o2 < 0 and o3 * o4 < 0:
        return True
    
    # Special cases (collinear)
    if o1 == 0 and on_segment(p1, p2, q1):
        return True
    if o2 == 0 and on_segment(p1, q2, q1):
        return True
    if o3 == 0 and on_segment(p2, p1, q2):
        return True
    if o4 == 0 and on_segment(p2, q1, q2):
        return True
    
    return False
\end{lstlisting}

\subsection{Convex Hull}
\textbf{Description:} Find convex hull using Graham's scan. Time: O(n log n).

\begin{lstlisting}
def convex_hull(points):
    # Graham's scan algorithm
    points = sorted(points)  # Sort by x, then y
    
    if len(points) <= 2:
        return points
    
    # Build lower hull
    lower = []
    for p in points:
        while (len(lower) >= 2 and 
               cross_product(lower[-2], lower[-1], p) <= 0):
            lower.pop()
        lower.append(p)
    
    # Build upper hull
    upper = []
    for p in reversed(points):
        while (len(upper) >= 2 and 
               cross_product(upper[-2], upper[-1], p) <= 0):
            upper.pop()
        upper.append(p)
    
    # Remove last point (duplicate of first)
    return lower[:-1] + upper[:-1]

# Convex hull area
def polygon_area(points):
    # Shoelace formula
    n = len(points)
    area = 0
    
    for i in range(n):
        j = (i + 1) % n
        area += points[i][0] * points[j][1]
        area -= points[j][0] * points[i][1]
    
    return abs(area) / 2
\end{lstlisting}

\subsection{Point in Polygon}
\textbf{Description:} Check if point is inside polygon. Time: O(n).

\begin{lstlisting}
def point_in_polygon(point, polygon):
    # Ray casting algorithm
    x, y = point
    n = len(polygon)
    inside = False
    
    p1x, p1y = polygon[0]
    for i in range(1, n + 1):
        p2x, p2y = polygon[i % n]
        
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        xinters = (y - p1y) * (p2x - p1x) / \
                                  (p2y - p1y) + p1x
                    
                    if p1x == p2x or x <= xinters:
                        inside = not inside
        
        p1x, p1y = p2x, p2y
    
    return inside
\end{lstlisting}

\subsection{Closest Pair of Points}
\textbf{Description:} Find closest pair using divide and conquer. Time: O(n log n).

\begin{lstlisting}
def closest_pair(points):
    points_sorted_x = sorted(points, key=lambda p: p[0])
    points_sorted_y = sorted(points, key=lambda p: p[1])
    
    def closest_recursive(px, py):
        n = len(px)
        
        # Base case: brute force
        if n <= 3:
            min_dist = float('inf')
            for i in range(n):
                for j in range(i + 1, n):
                    min_dist = min(min_dist, dist(px[i], px[j]))
            return min_dist
        
        # Divide
        mid = n // 2
        midpoint = px[mid]
        
        pyl = [p for p in py if p[0] <= midpoint[0]]
        pyr = [p for p in py if p[0] > midpoint[0]]
        
        # Conquer
        dl = closest_recursive(px[:mid], pyl)
        dr = closest_recursive(px[mid:], pyr)
        d = min(dl, dr)
        
        # Combine: check strip
        strip = [p for p in py if abs(p[0] - midpoint[0]) < d]
        
        for i in range(len(strip)):
            j = i + 1
            while j < len(strip) and strip[j][1] - strip[i][1] < d:
                d = min(d, dist(strip[i], strip[j]))
                j += 1
        
        return d
    
    return closest_recursive(points_sorted_x, points_sorted_y)
\end{lstlisting}
