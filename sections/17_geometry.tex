\section{Computational Geometry}

\subsection{Basic Geometry}
\textbf{Description:} Fundamental geometric operations for 2D points.

\begin{lstlisting}
# Assumes `math` and basic constants (e.g. EPS) are available — see Mathematics section for shared imports.

# Point operations
def dist(p1, p2):
    # Euclidean distance
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def cross_product(O, A, B):
    # Cross product of vectors OA and OB
    # Positive: counter-clockwise
    # Negative: clockwise
    # Zero: collinear
    return (A[0] - O[0]) * (B[1] - O[1]) - \
           (A[1] - O[1]) * (B[0] - O[0])

def dot_product(A, B, C, D):
    # Dot product of vectors AB and CD
    return (B[0] - A[0]) * (D[0] - C[0]) + \
           (B[1] - A[1]) * (D[1] - C[1])

# Check if point is on segment
def on_segment(p, q, r):
    # Check if q lies on segment pr
    return (q[0] <= max(p[0], r[0]) and 
            q[0] >= min(p[0], r[0]) and
            q[1] <= max(p[1], r[1]) and 
            q[1] >= min(p[1], r[1]))

# Segment intersection
def segments_intersect(p1, q1, p2, q2):
    o1 = cross_product(p1, q1, p2)
    o2 = cross_product(p1, q1, q2)
    o3 = cross_product(p2, q2, p1)
    o4 = cross_product(p2, q2, q1)
    
    # General case
    if o1 * o2 < 0 and o3 * o4 < 0:
        return True
    
    # Special cases (collinear)
    if o1 == 0 and on_segment(p1, p2, q1):
        return True
    if o2 == 0 and on_segment(p1, q2, q1):
        return True
    if o3 == 0 and on_segment(p2, p1, q2):
        return True
    if o4 == 0 and on_segment(p2, q1, q2):
        return True
    
    return False
\end{lstlisting}

\subsection{Convex Hull}
\textbf{Description:} Find convex hull using Graham's scan. Time: O(n log n).

\begin{lstlisting}
def convex_hull(points):
    # Graham's scan algorithm
    points = sorted(points)  # Sort by x, then y
    
    if len(points) <= 2:
        return points
    
    # Build lower hull
    lower = []
    for p in points:
        while (len(lower) >= 2 and 
               cross_product(lower[-2], lower[-1], p) <= 0):
            lower.pop()
        lower.append(p)
    
    # Build upper hull
    upper = []
    for p in reversed(points):
        while (len(upper) >= 2 and 
               cross_product(upper[-2], upper[-1], p) <= 0):
            upper.pop()
        upper.append(p)
    
    # Remove last point (duplicate of first)
    return lower[:-1] + upper[:-1]

# Convex hull area
def polygon_area(points):
    # Shoelace formula
    n = len(points)
    area = 0
    
    for i in range(n):
        j = (i + 1) % n
        area += points[i][0] * points[j][1]
        area -= points[j][0] * points[i][1]
    
    return abs(area) / 2
\end{lstlisting}

\subsection{Point in Polygon}
\textbf{Description:} Check if point is inside polygon. Time: O(n).

\begin{lstlisting}
def point_in_polygon(point, polygon):
    # Ray casting algorithm
    x, y = point
    n = len(polygon)
    inside = False
    
    p1x, p1y = polygon[0]
    for i in range(1, n + 1):
        p2x, p2y = polygon[i % n]
        
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        xinters = (y - p1y) * (p2x - p1x) / \
                                  (p2y - p1y) + p1x
                    
                    if p1x == p2x or x <= xinters:
                        inside = not inside
        
        p1x, p1y = p2x, p2y
    
    return inside
\end{lstlisting}

\subsection{Closest Pair of Points}
\textbf{Description:} Find closest pair using divide and conquer. Time: O(n log n).

\begin{lstlisting}
def closest_pair(points):
    points_sorted_x = sorted(points, key=lambda p: p[0])
    points_sorted_y = sorted(points, key=lambda p: p[1])
    
    def closest_recursive(px, py):
        n = len(px)
        
        # Base case: brute force
        if n <= 3:
            min_dist = float('inf')
            for i in range(n):
                for j in range(i + 1, n):
                    min_dist = min(min_dist, dist(px[i], px[j]))
            return min_dist
        
        # Divide
        mid = n // 2
        midpoint = px[mid]
        
        pyl = [p for p in py if p[0] <= midpoint[0]]
        pyr = [p for p in py if p[0] > midpoint[0]]
        
        # Conquer
        dl = closest_recursive(px[:mid], pyl)
        dr = closest_recursive(px[mid:], pyr)
        d = min(dl, dr)
        
        # Combine: check strip
        strip = [p for p in py if abs(p[0] - midpoint[0]) < d]
        
        for i in range(len(strip)):
            j = i + 1
            while j < len(strip) and strip[j][1] - strip[i][1] < d:
                d = min(d, dist(strip[i], strip[j]))
                j += 1
        
        return d
    
    return closest_recursive(points_sorted_x, points_sorted_y)
\end{lstlisting}

\subsection{Robust techniques and helpers for ICPC}
\textbf{Description:} Practical tips and helper functions that make geometric code safer and easier to reason about in contests: prefer integer arithmetic when possible, use exact rationals for intersections, and common utilities.

\begin{lstlisting}
# Assumes `math`, `Fraction` and shared constants (EPS) are available — see Mathematics section for shared imports.

# Vector helpers
def vec(a, b):
    return (b[0] - a[0], b[1] - a[1])

def cross_vec(u, v):
    return u[0] * v[1] - u[1] * v[0]

def dot_vec(u, v):
    return u[0] * v[0] + u[1] * v[1]

# Signed orientation: >0 = ccw, <0 = cw, 0 = collinear
def orient(a, b, c):
    return cross_vec(vec(a, b), vec(a, c))

# Twice signed polygon area (integer if points are integer)
def polygon_area2(poly):
    s = 0
    n = len(poly)
    for i in range(n):
        j = (i + 1) % n
        s += cross_vec(poly[i], poly[j])
    return s

# Exact intersection point of two lines (a-b) and (c-d)
# Returns (Fraction, Fraction) or None when parallel/collinear
def line_intersection(a, b, c, d):
    r = vec(a, b)
    s = vec(c, d)
    rxs = cross_vec(r, s)
    if rxs == 0:
        return None
    t_num = cross_vec(vec(a, c), s)
    t = Fraction(t_num, rxs)
    return (Fraction(a[0]) + t * Fraction(r[0]), Fraction(a[1]) + t * Fraction(r[1]))

# Project point p onto line a-b, returns a point (float)
def project_point_on_line(a, b, p):
    r = vec(a, b)
    if r == (0, 0):
        return a
    t = dot_vec(vec(a, p), r) / dot_vec(r, r)
    return (a[0] + t * r[0], a[1] + t * r[1])

# Distance from point p to line a-b (float)
def point_line_distance(a, b, p):
    r = vec(a, b)
    if r == (0, 0):
        return dist(a, p)
    return abs(cross_vec(vec(a, b), vec(a, p))) / math.hypot(r[0], r[1])

# Rotate point p around origin by theta (radians)
def rotate(p, theta):
    x, y = p
    c, s = math.cos(theta), math.sin(theta)
    return (x * c - y * s, x * s + y * c)

# Polar sort key around origin (or given center)
def polar_sort_key(origin=(0,0)):
    def key(p):
        return (math.atan2(p[1]-origin[1], p[0]-origin[0]), (p[0]-origin[0])**2 + (p[1]-origin[1])**2)
    return key

# Rotating calipers to compute diameter (farthest pair) of convex polygon
# convex_hull is expected to return points in CCW order without duplicate endpoints
def diameter(convex):
    n = len(convex)
    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return math.hypot(convex[0][0]-convex[1][0], convex[0][1]-convex[1][1])

    def sqdist(i, j):
        dx = convex[i][0] - convex[j][0]
        dy = convex[i][1] - convex[j][1]
        return dx*dx + dy*dy

    j = 1
    best = 0
    for i in range(n):
        ni = (i + 1) % n
        while True:
            nj = (j + 1) % n
            cur = abs(cross_vec(vec(convex[i], convex[ni]), vec(convex[j], convex[nj])))
            nex = abs(cross_vec(vec(convex[i], convex[ni]), vec(convex[nj], convex[(nj+1)%n]))) if False else None
            # move j while area increases (alternate robust check below)
            if dot_vec(vec(convex[i], convex[ni]), vec(convex[j], convex[nj])) > 0:
                j = nj
            else:
                break
        best = max(best, sqdist(i, j))
    return math.sqrt(best)

# Tips:
# - Prefer integer arithmetic (area2, orientation) whenever possible.
# - Use Fraction for exact intersections if you must compare intersection coordinates.
# - Avoid atan2 in tight loops; use cross/dot for comparisons when possible.
\end{lstlisting}
