\section{Array Techniques}

\subsection{Prefix Sum}
\textbf{Description:} Precompute cumulative sums for O(1) range queries. Time: O(n) preprocessing, O(1) query.

\begin{lstlisting}
# 1D prefix sum
prefix = [0] * (n + 1)
for i in range(n):
    prefix[i + 1] = prefix[i] + arr[i]

# Range sum query [l, r] inclusive
range_sum = prefix[r + 1] - prefix[l]

# 2D prefix sum - for rectangle sum queries
def build_2d_prefix(matrix):
    n, m = len(matrix), len(matrix[0])
    prefix = [[0] * (m + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            prefix[i][j] = (matrix[i-1][j-1] + 
                           prefix[i-1][j] + 
                           prefix[i][j-1] - 
                           prefix[i-1][j-1])
    
    return prefix

# Rectangle sum from (x1,y1) to (x2,y2) inclusive
def rect_sum(prefix, x1, y1, x2, y2):
    return (prefix[x2+1][y2+1] - 
            prefix[x1][y2+1] - 
            prefix[x2+1][y1] + 
            prefix[x1][y1])
\end{lstlisting}

\subsection{Difference Array}
\textbf{Description:} Efficiently perform range updates. O(1) per update, O(n) to reconstruct.

\begin{lstlisting}
# Initialize difference array
diff = [0] * (n + 1)

# Add 'val' to range [l, r]
def range_update(diff, l, r, val):
    diff[l] += val
    diff[r + 1] -= val

# After all updates, reconstruct array
def reconstruct(diff):
    result = []
    current = 0
    for i in range(len(diff) - 1):
        current += diff[i]
        result.append(current)
    return result

# Example: Multiple range updates
diff = [0] * (n + 1)
for l, r, val in updates:
    range_update(diff, l, r, val)
final_array = reconstruct(diff)
\end{lstlisting}

\subsection{Sliding Window}
\textbf{Description:} Maintain a window of elements while traversing. Time: O(n).

\begin{lstlisting}
# Fixed size window
def max_sum_window(arr, k):
    window_sum = sum(arr[:k])
    max_sum = window_sum
    
    # Slide window: add right, remove left
    for i in range(k, len(arr)):
        window_sum += arr[i] - arr[i - k]
        max_sum = max(max_sum, window_sum)
    
    return max_sum

# Variable size window - two pointers
def min_subarray_sum_geq_target(arr, target):
    left = 0
    current_sum = 0
    min_len = float('inf')
    
    for right in range(len(arr)):
        current_sum += arr[right]
        
        # Shrink window while condition holds
        while current_sum >= target:
            min_len = min(min_len, right - left + 1)
            current_sum -= arr[left]
            left += 1
    
    return min_len if min_len != float('inf') else 0

# Longest substring with at most k distinct chars
def longest_k_distinct(s, k):
    from collections import defaultdict
    
    left = 0
    char_count = defaultdict(int)
    max_len = 0
    
    for right in range(len(s)):
        char_count[s[right]] += 1
        
        # Shrink if too many distinct
        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]
            left += 1
        
        max_len = max(max_len, right - left + 1)
    
    return max_len
\end{lstlisting}
