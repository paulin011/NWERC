\section{Number Theory}

\textbf{Description:} Essential algorithms for problems involving primes, modular arithmetic, and divisibility.

\subsection{Modular Arithmetic}
\begin{lstlisting}
# Modular inverse using Fermat's Little Theorem
# Only works when mod is prime
# a^(-1) = a^(mod-2) (mod p)
def modinv(a, mod):
    return pow(a, mod - 2, mod)

# Extended Euclidean Algorithm
# Returns (gcd, x, y) where ax + by = gcd(a,b)
# Can find modular inverse for any coprime a,mod
def extgcd(a, b):
    if b == 0:
        return a, 1, 0
    g, x1, y1 = extgcd(b, a % b)
    x = y1
    y = x1 - (a // b) * y1
    return g, x, y
\end{lstlisting}

\subsection{Sieve of Eratosthenes}
\textbf{Description:} Find all primes up to n in O(n log log n) time. Memory: O(n).

\begin{lstlisting}
def sieve(n):
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False
    
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            # Mark multiples as composite
            for j in range(i*i, n + 1, i):
                is_prime[j] = False
    
    return is_prime

# Get list of primes
primes = [i for i in range(n+1) if is_prime[i]]
\end{lstlisting}

\subsection{Prime Factorization}
\textbf{Description:} Decompose n into prime factors in O(sqrt(n)) time.

\begin{lstlisting}
def factorize(n):
    factors = []
    d = 2
    
    # Check divisors up to sqrt(n)
    while d * d <= n:
        while n % d == 0:
            factors.append(d)
            n //= d
        d += 1
    
    # If n > 1, it's a prime factor
    if n > 1:
        factors.append(n)
    
    return factors

# Get prime factors with counts
from collections import Counter
def prime_factor_counts(n):
    return Counter(factorize(n))

# Count divisors
def count_divisors(n):
    count = 0
    i = 1
    while i * i <= n:
        if n % i == 0:
            count += 1 if i * i == n else 2
        i += 1
    return count

# Sum of divisors
def sum_divisors(n):
    total = 0
    i = 1
    while i * i <= n:
        if n % i == 0:
            total += i
            if i != n // i:
                total += n // i
        i += 1
    return total
\end{lstlisting}

\subsection{Chinese Remainder Theorem}
\textbf{Description:} Solve system of congruences x ≡ a₁ (mod m₁), x ≡ a₂ (mod m₂), ... Time: O(n log M) where M is product of moduli.

\begin{lstlisting}
def chinese_remainder(remainders, moduli):
    # Solve x ≡ remainders[i] (mod moduli[i])
    # Assumes moduli are pairwise coprime
    
    def extgcd(a, b):
        if b == 0:
            return a, 1, 0
        g, x1, y1 = extgcd(b, a % b)
        return g, y1, x1 - (a // b) * y1
    
    total = 0
    prod = 1
    for m in moduli:
        prod *= m
    
    for r, m in zip(remainders, moduli):
        p = prod // m
        _, inv, _ = extgcd(p, m)
        total += r * inv * p
    
    return total % prod
\end{lstlisting}

\subsection{Euler's Totient Function}
\textbf{Description:} φ(n) = count of numbers ≤ n coprime to n. Time: O(√n).

\begin{lstlisting}
def euler_phi(n):
    result = n
    p = 2
    
    while p * p <= n:
        if n % p == 0:
            # Remove factor p
            while n % p == 0:
                n //= p
            # Multiply by (1 - 1/p)
            result -= result // p
        p += 1
    
    if n > 1:
        result -= result // n
    
    return result

# Phi for range [1, n] using sieve
def phi_sieve(n):
    phi = list(range(n + 1))  # phi[i] = i initially
    
    for i in range(2, n + 1):
        if phi[i] == i:  # i is prime
            for j in range(i, n + 1, i):
                phi[j] -= phi[j] // i
    
    return phi
\end{lstlisting}

\subsection{Fast Exponentiation with Matrix}
\textbf{Description:} Already covered in matrix section, but useful pattern.

\begin{lstlisting}
# Modular exponentiation
def mod_exp(base, exp, mod):
    result = 1
    base %= mod
    
    while exp > 0:
        if exp & 1:
            result = (result * base) % mod
        base = (base * base) % mod
        exp >>= 1
    
    return result
\end{lstlisting}
