\section{Dynamic Programming}

\textbf{Description:} Solve problems by breaking them into overlapping subproblems. Store results to avoid recomputation.

\subsection{Longest Increasing Subsequence}
\textbf{Description:} Find length of longest strictly increasing subsequence. Time: O(n log n) using binary search.

\begin{lstlisting}
def lis(arr):
    from bisect import bisect_left
    
    # dp[i] = smallest ending value of LIS of length i+1
    dp = []
    
    for x in arr:
        # Find position to place x
        idx = bisect_left(dp, x)
        
        if idx == len(dp):
            dp.append(x)  # Extend LIS
        else:
            dp[idx] = x   # Better ending for this length
    
    return len(dp)

# LIS with actual sequence
def lis_with_sequence(arr):
    from bisect import bisect_left
    
    n = len(arr)
    dp = []
    parent = [-1] * n
    dp_idx = []  # indices in dp
    
    for i, x in enumerate(arr):
        idx = bisect_left(dp, x)
        
        if idx == len(dp):
            dp.append(x)
            dp_idx.append(i)
        else:
            dp[idx] = x
            dp_idx[idx] = i
        
        if idx > 0:
            parent[i] = dp_idx[idx - 1]
    
    # Reconstruct sequence
    result = []
    idx = dp_idx[-1]
    while idx != -1:
        result.append(arr[idx])
        idx = parent[idx]
    
    return result[::-1]
\end{lstlisting}

\subsection{0/1 Knapsack}
\textbf{Description:} Maximum value with weight capacity. Each item can be taken 0 or 1 time. Time: O(n×capacity), Space: O(n×capacity).

\begin{lstlisting}
def knapsack(weights, values, capacity):
    n = len(weights)
    # dp[i][w] = max value using first i items, 
    #            weight <= w
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # Don't take item i-1
            dp[i][w] = dp[i-1][w]
            
            # Take item i-1 if it fits
            if weights[i-1] <= w:
                dp[i][w] = max(
                    dp[i][w],
                    dp[i-1][w - weights[i-1]] + values[i-1]
                )
    
    return dp[n][capacity]

# Space-optimized O(capacity)
def knapsack_optimized(weights, values, capacity):
    dp = [0] * (capacity + 1)
    
    for i in range(len(weights)):
        # Iterate backwards to avoid using updated values
        for w in range(capacity, weights[i] - 1, -1):
            dp[w] = max(dp[w], 
                       dp[w - weights[i]] + values[i])
    
    return dp[capacity]
\end{lstlisting}

\subsection{Edit Distance (Levenshtein Distance)}
\textbf{Description:} Minimum operations (insert, delete, replace) to transform s1 to s2. Time: O(m×n), Space: O(m×n).

\begin{lstlisting}
def edit_dist(s1, s2):
    m, n = len(s1), len(s2)
    # dp[i][j] = edit distance of s1[:i] and s2[:j]
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Base cases: empty string transformations
    for i in range(m + 1):
        dp[i][0] = i  # Delete all
    for j in range(n + 1):
        dp[0][j] = j  # Insert all
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                # Characters match, no operation needed
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(
                    dp[i-1][j],      # Delete from s1
                    dp[i][j-1],      # Insert into s1
                    dp[i-1][j-1]     # Replace in s1
                )
    
    return dp[m][n]
\end{lstlisting}

\subsection{Longest Common Subsequence (LCS)}
\textbf{Description:} Longest subsequence common to two sequences. Time: O(m×n).

\begin{lstlisting}
def lcs(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

# Reconstruct LCS
def lcs_string(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    # Backtrack
    result = []
    i, j = m, n
    while i > 0 and j > 0:
        if s1[i-1] == s2[j-1]:
            result.append(s1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1
    
    return ''.join(reversed(result))
\end{lstlisting}

\subsection{Coin Change}
\textbf{Description:} Minimum coins to make amount, or count ways. Time: O(n×amount).

\begin{lstlisting}
# Minimum coins
def coin_change_min(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1

# Count ways
def coin_change_ways(coins, amount):
    dp = [0] * (amount + 1)
    dp[0] = 1
    
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]
    
    return dp[amount]
\end{lstlisting}

\subsection{Palindrome Partitioning}
\textbf{Description:} Minimum cuts to partition string into palindromes. Time: O(n²).

\begin{lstlisting}
def min_palindrome_partition(s):
    n = len(s)
    
    # is_pal[i][j] = True if s[i:j+1] is palindrome
    is_pal = [[False] * n for _ in range(n)]
    
    # Every single character is palindrome
    for i in range(n):
        is_pal[i][i] = True
    
    # Check all substrings
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                is_pal[i][j] = (length == 2 or 
                               is_pal[i+1][j-1])
    
    # dp[i] = min cuts for s[0:i+1]
    dp = [float('inf')] * n
    
    for i in range(n):
        if is_pal[0][i]:
            dp[i] = 0
        else:
            for j in range(i):
                if is_pal[j+1][i]:
                    dp[i] = min(dp[i], dp[j] + 1)
    
    return dp[n-1]
\end{lstlisting}

\subsection{Subset Sum}
\textbf{Description:} Check if subset sums to target. Time: O(n×sum).

\begin{lstlisting}
def subset_sum(arr, target):
    n = len(arr)
    dp = [[False] * (target + 1) for _ in range(n + 1)]
    
    # Base case: sum 0 is always achievable
    for i in range(n + 1):
        dp[i][0] = True
    
    for i in range(1, n + 1):
        for s in range(target + 1):
            # Don't take arr[i-1]
            dp[i][s] = dp[i-1][s]
            
            # Take arr[i-1] if possible
            if s >= arr[i-1]:
                dp[i][s] = dp[i][s] or dp[i-1][s - arr[i-1]]
    
    return dp[n][target]

# Space optimized
def subset_sum_optimized(arr, target):
    dp = [False] * (target + 1)
    dp[0] = True
    
    for num in arr:
        for s in range(target, num - 1, -1):
            dp[s] = dp[s] or dp[s - num]
    
    return dp[target]
\end{lstlisting}
