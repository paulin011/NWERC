\section{Basic Data Structures}

\subsection{List Operations}
\textbf{Description:} Python lists are dynamic arrays with O(1) amortized append and O(n) insert/delete at arbitrary positions.

\begin{lstlisting}
# Initialize lists
arr = [0] * n  # n zeros
matrix = [[0] * m for _ in range(n)]  # Correct way!

# List comprehension - concise and efficient
squares = [x**2 for x in range(n)]
evens = [x for x in arr if x % 2 == 0]

# Sorting - O(n log n)
arr.sort()  # in-place, modifies arr
arr.sort(reverse=True)  # descending
arr.sort(key=lambda x: (x[0], -x[1]))  # custom
sorted_arr = sorted(arr)  # returns new list

# Binary search in sorted array
from bisect import bisect_left, bisect_right
idx = bisect_left(arr, x)   # leftmost position
idx = bisect_right(arr, x)  # rightmost position

# Common operations
arr.append(x)      # O(1) amortized
arr.pop()          # O(1) - remove last
arr.pop(0)         # O(n) - remove first (slow!)
arr.reverse()      # O(n) - in-place
arr.count(x)       # O(n) - count occurrences
arr.index(x)       # O(n) - first occurrence
\end{lstlisting}

\subsection{Deque (Double-ended Queue)}
\textbf{Description:} Deque (pronounced "deck") provides O(1) append and pop operations from both ends, unlike lists which have O(n) for operations at the front. Essential for BFS, sliding window problems, implementing efficient queues/stacks, and maintaining monotonic queues. Use when you need fast insertions/deletions at both ends.

\begin{lstlisting}
from collections import deque
dq = deque()

# O(1) operations on both ends
dq.append(x)       # add to right
dq.appendleft(x)   # add to left
dq.pop()           # remove from right
dq.popleft()       # remove from left

# Sliding window maximum - O(n)
# Maintains decreasing order of elements
def sliding_max(arr, k):
    dq = deque()  # stores indices
    result = []
    
    for i in range(len(arr)):
        # Remove indices outside window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Remove smaller elements (not useful)
        while dq and arr[dq[-1]] < arr[i]:
            dq.pop()
        
        dq.append(i)
        if i >= k - 1:
            result.append(arr[dq[0]])
    
    return result
\end{lstlisting}

\subsection{Heap (Priority Queue)}
\textbf{Description:} Python's heapq module implements a min-heap (smallest element always at index 0). Provides O(log n) insert and extract-min operations, O(n) heapify, and O(1) peek. For max-heap, negate values before insertion. Critical for Dijkstra's algorithm, Prim's MST, k-th largest/smallest problems, merge k sorted lists, and any problem requiring repeated access to minimum/maximum elements. More efficient than sorting when you only need partial ordering.

\begin{lstlisting}
import heapq

# Min heap (default)
heap = []
heapq.heappush(heap, x)        # O(log n)
min_val = heapq.heappop(heap)  # O(log n)
min_val = heap[0]              # O(1) peek

# Max heap - negate values
heapq.heappush(heap, -x)
max_val = -heapq.heappop(heap)

# Convert list to heap in-place - O(n)
heapq.heapify(arr)

# K largest/smallest - O(n log k)
k_largest = heapq.nlargest(k, arr)
k_smallest = heapq.nsmallest(k, arr)

# Custom comparator using tuples
# Compares first element, then second, etc.
heapq.heappush(heap, (priority, item))
\end{lstlisting}

\subsection{Dictionary \& Counter}
\textbf{Description:} Hash maps with O(1) average case insert/lookup. Counter is specialized for counting occurrences.

\begin{lstlisting}
from collections import defaultdict, Counter

# defaultdict - provides default value
graph = defaultdict(list)  # empty list default
count = defaultdict(int)   # 0 default

# Counter - count elements efficiently
cnt = Counter(arr)
cnt['x'] += 1
most_common = cnt.most_common(k)  # k most frequent

# Dictionary operations
d = {}
d.get(key, default_val)
d.setdefault(key, default_val)
for k, v in d.items():
    pass
\end{lstlisting}

\subsection{Set Operations}
\textbf{Description:} Hash sets provide O(1) average-case membership testing, insertion, and deletion. Unlike lists, sets store only unique elements (no duplicates) and are unordered. Essential for removing duplicates, fast membership queries, and mathematical set operations (union, intersection, difference). Use when element uniqueness matters or you need fast lookups without caring about order. For sorted sets, consider using sorted containers or maintaining a sorted list separately.

\begin{lstlisting}
s = set()
s.add(x)         # O(1)
s.remove(x)      # O(1), KeyError if not exists
s.discard(x)     # O(1), no error if not exists

# Set operations - all O(n)
a | b   # union
a & b   # intersection
a - b   # difference
a ^ b   # symmetric difference

# Ordered set workaround
from collections import OrderedDict
oset = OrderedDict.fromkeys([])
\end{lstlisting}

\subsection{Skip List}
\textbf{Description:} Skip lists are probabilistic balanced data structures that support O(log n) expected time for search, insert, and delete. They are an alternative to balanced BSTs and are simple to implement. Good when you want ordered set/map operations with expected logarithmic time.

\textbf{How it works:} A skip list is composed of multiple levels of sorted linked lists; level~0 contains all elements and higher levels act as ``express lanes'' with a subset of elements (each element appears in a random number of levels, forming a ``tower''). To search, start at the head on the highest level, move right while the next key is less than the target, and drop down one level when you can no longer move right; repeat until level~0. New node levels are chosen randomly with probability $p$ (common choice $p=0.5$). For contests, use $p=0.5$ and $L_{\max} \approx \lceil \log_{2} N \rceil + 2$ for safety.

\begin{lstlisting}
import random

class SkipNode:
    def __init__(self, key, value=None, level=0):
        self.key = key
        self.value = value
        # forward pointers for levels 0..level
        self.forward = [None] * (level + 1)

class SkipList:
    def __init__(self, max_level=16, p=0.5):
        self.max_level = max_level
        self.p = p
        self.level = 0
        self.head = SkipNode(None, level=max_level)

    def random_level(self):
        lvl = 0
        while random.random() < self.p and lvl < self.max_level:
            lvl += 1
        return lvl

    def search(self, key):
        node = self.head
        # start from highest level
        for i in range(self.level, -1, -1):
            while node.forward[i] and node.forward[i].key < key:
                node = node.forward[i]
        node = node.forward[0]
        if node and node.key == key:
            return node.value
        return None

    def insert(self, key, value=None):
        update = [None] * (self.max_level + 1)
        node = self.head
        for i in range(self.level, -1, -1):
            while node.forward[i] and node.forward[i].key < key:
                node = node.forward[i]
            update[i] = node
        node = node.forward[0]

        # If key exists, update value
        if node and node.key == key:
            node.value = value
            return

        lvl = self.random_level()
        if lvl > self.level:
            for i in range(self.level + 1, lvl + 1):
                update[i] = self.head
            self.level = lvl

        new_node = SkipNode(key, value, lvl)
        for i in range(lvl + 1):
            new_node.forward[i] = update[i].forward[i]
            update[i].forward[i] = new_node

    def delete(self, key):
        update = [None] * (self.max_level + 1)
        node = self.head
        for i in range(self.level, -1, -1):
            while node.forward[i] and node.forward[i].key < key:
                node = node.forward[i]
            update[i] = node
        node = node.forward[0]

        if not node or node.key != key:
            return False  # not found

        for i in range(self.level + 1):
            if update[i].forward[i] != node:
                break
            update[i].forward[i] = node.forward[i]

        # adjust current level
        while self.level > 0 and self.head.forward[self.level] is None:
            self.level -= 1
        return True

# Example usage:
# s = SkipList()
# s.insert(10, 'ten')
# print(s.search(10))
# s.delete(10)
\end{lstlisting}
