\section{Basic Data Structures}

\subsection{List Operations}
\textbf{Description:} Python lists are dynamic arrays with O(1) amortized append and O(n) insert/delete at arbitrary positions.

\begin{lstlisting}
# Initialize lists
arr = [0] * n  # n zeros
matrix = [[0] * m for _ in range(n)]  # Correct way!

# List comprehension - concise and efficient
squares = [x**2 for x in range(n)]
evens = [x for x in arr if x % 2 == 0]

# Sorting - O(n log n)
arr.sort()  # in-place, modifies arr
arr.sort(reverse=True)  # descending
arr.sort(key=lambda x: (x[0], -x[1]))  # custom
sorted_arr = sorted(arr)  # returns new list

# Binary search in sorted array
from bisect import bisect_left, bisect_right
idx = bisect_left(arr, x)   # leftmost position
idx = bisect_right(arr, x)  # rightmost position

# Common operations
arr.append(x)      # O(1) amortized
arr.pop()          # O(1) - remove last
arr.pop(0)         # O(n) - remove first (slow!)
arr.reverse()      # O(n) - in-place
arr.count(x)       # O(n) - count occurrences
arr.index(x)       # O(n) - first occurrence
\end{lstlisting}

\subsection{Deque (Double-ended Queue)}
\textbf{Description:} Deque (pronounced "deck") provides O(1) append and pop operations from both ends, unlike lists which have O(n) for operations at the front. Essential for BFS, sliding window problems, implementing efficient queues/stacks, and maintaining monotonic queues. Use when you need fast insertions/deletions at both ends.

\begin{lstlisting}
from collections import deque
dq = deque()

# O(1) operations on both ends
dq.append(x)       # add to right
dq.appendleft(x)   # add to left
dq.pop()           # remove from right
dq.popleft()       # remove from left

# Sliding window maximum - O(n)
# Maintains decreasing order of elements
def sliding_max(arr, k):
    dq = deque()  # stores indices
    result = []
    
    for i in range(len(arr)):
        # Remove indices outside window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Remove smaller elements (not useful)
        while dq and arr[dq[-1]] < arr[i]:
            dq.pop()
        
        dq.append(i)
        if i >= k - 1:
            result.append(arr[dq[0]])
    
    return result
\end{lstlisting}

\subsection{Heap (Priority Queue)}
\textbf{Description:} Python's heapq module implements a min-heap (smallest element always at index 0). Provides O(log n) insert and extract-min operations, O(n) heapify, and O(1) peek. For max-heap, negate values before insertion. Critical for Dijkstra's algorithm, Prim's MST, k-th largest/smallest problems, merge k sorted lists, and any problem requiring repeated access to minimum/maximum elements. More efficient than sorting when you only need partial ordering.

\begin{lstlisting}
import heapq

# Min heap (default)
heap = []
heapq.heappush(heap, x)        # O(log n)
min_val = heapq.heappop(heap)  # O(log n)
min_val = heap[0]              # O(1) peek

# Max heap - negate values
heapq.heappush(heap, -x)
max_val = -heapq.heappop(heap)

# Convert list to heap in-place - O(n)
heapq.heapify(arr)

# K largest/smallest - O(n log k)
k_largest = heapq.nlargest(k, arr)
k_smallest = heapq.nsmallest(k, arr)

# Custom comparator using tuples
# Compares first element, then second, etc.
heapq.heappush(heap, (priority, item))
\end{lstlisting}

\subsection{Dictionary \& Counter}
\textbf{Description:} Hash maps with O(1) average case insert/lookup. Counter is specialized for counting occurrences.

\begin{lstlisting}
from collections import defaultdict, Counter

# defaultdict - provides default value
graph = defaultdict(list)  # empty list default
count = defaultdict(int)   # 0 default

# Counter - count elements efficiently
cnt = Counter(arr)
cnt['x'] += 1
most_common = cnt.most_common(k)  # k most frequent

# Dictionary operations
d = {}
d.get(key, default_val)
d.setdefault(key, default_val)
for k, v in d.items():
    pass
\end{lstlisting}

\subsection{Set Operations}
\textbf{Description:} Hash sets provide O(1) average-case membership testing, insertion, and deletion. Unlike lists, sets store only unique elements (no duplicates) and are unordered. Essential for removing duplicates, fast membership queries, and mathematical set operations (union, intersection, difference). Use when element uniqueness matters or you need fast lookups without caring about order. For sorted sets, consider using sorted containers or maintaining a sorted list separately.

\begin{lstlisting}
s = set()
s.add(x)         # O(1)
s.remove(x)      # O(1), KeyError if not exists
s.discard(x)     # O(1), no error if not exists

# Set operations - all O(n)
a | b   # union
a & b   # intersection
a - b   # difference
a ^ b   # symmetric difference

# Ordered set workaround
from collections import OrderedDict
oset = OrderedDict.fromkeys([])
\end{lstlisting}
