\section{Basic Data Structures}

\subsection{List Operations}
\textbf{Description:} Python lists are dynamic arrays with O(1) amortized append and O(n) insert/delete at arbitrary positions.

\begin{lstlisting}
# Initialize lists
arr = [0] * n  # n zeros
matrix = [[0] * m for _ in range(n)]  # Correct way!

# List comprehension - concise and efficient
squares = [x**2 for x in range(n)]
evens = [x for x in arr if x % 2 == 0]

# Sorting - O(n log n)
arr.sort()  # in-place, modifies arr
arr.sort(reverse=True)  # descending
arr.sort(key=lambda x: (x[0], -x[1]))  # custom
sorted_arr = sorted(arr)  # returns new list

# Binary search in sorted array
from bisect import bisect_left, bisect_right
idx = bisect_left(arr, x)   # leftmost position
idx = bisect_right(arr, x)  # rightmost position

# Common operations
arr.append(x)      # O(1) amortized
arr.pop()          # O(1) - remove last
arr.pop(0)         # O(n) - remove first (slow!)
arr.reverse()      # O(n) - in-place
arr.count(x)       # O(n) - count occurrences
arr.index(x)       # O(n) - first occurrence
\end{lstlisting}

\subsection{Deque (Double-ended Queue)}
\textbf{Description:} Deque provides O(1) append and pop from both ends, making it ideal for sliding window problems and implementing queues/stacks efficiently.

\begin{lstlisting}
from collections import deque
dq = deque()

# O(1) operations on both ends
dq.append(x)       # add to right
dq.appendleft(x)   # add to left
dq.pop()           # remove from right
dq.popleft()       # remove from left

# Sliding window maximum - O(n)
# Maintains decreasing order of elements
def sliding_max(arr, k):
    dq = deque()  # stores indices
    result = []
    
    for i in range(len(arr)):
        # Remove indices outside window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Remove smaller elements (not useful)
        while dq and arr[dq[-1]] < arr[i]:
            dq.pop()
        
        dq.append(i)
        if i >= k - 1:
            result.append(arr[dq[0]])
    
    return result
\end{lstlisting}

\subsection{Heap (Priority Queue)}
\textbf{Description:} Python's heapq implements a min-heap. For max-heap, negate values. Useful for finding k-th largest/smallest, Dijkstra's algorithm, and scheduling problems.

\begin{lstlisting}
import heapq

# Min heap (default)
heap = []
heapq.heappush(heap, x)        # O(log n)
min_val = heapq.heappop(heap)  # O(log n)
min_val = heap[0]              # O(1) peek

# Max heap - negate values
heapq.heappush(heap, -x)
max_val = -heapq.heappop(heap)

# Convert list to heap in-place - O(n)
heapq.heapify(arr)

# K largest/smallest - O(n log k)
k_largest = heapq.nlargest(k, arr)
k_smallest = heapq.nsmallest(k, arr)

# Custom comparator using tuples
# Compares first element, then second, etc.
heapq.heappush(heap, (priority, item))
\end{lstlisting}

\subsection{Dictionary \& Counter}
\textbf{Description:} Hash maps with O(1) average case insert/lookup. Counter is specialized for counting occurrences.

\begin{lstlisting}
from collections import defaultdict, Counter

# defaultdict - provides default value
graph = defaultdict(list)  # empty list default
count = defaultdict(int)   # 0 default

# Counter - count elements efficiently
cnt = Counter(arr)
cnt['x'] += 1
most_common = cnt.most_common(k)  # k most frequent

# Dictionary operations
d = {}
d.get(key, default_val)
d.setdefault(key, default_val)
for k, v in d.items():
    pass
\end{lstlisting}

\subsection{Set Operations}
\textbf{Description:} Hash sets provide O(1) membership testing and set operations.

\begin{lstlisting}
s = set()
s.add(x)         # O(1)
s.remove(x)      # O(1), KeyError if not exists
s.discard(x)     # O(1), no error if not exists

# Set operations - all O(n)
a | b   # union
a & b   # intersection
a - b   # difference
a ^ b   # symmetric difference

# Ordered set workaround
from collections import OrderedDict
oset = OrderedDict.fromkeys([])
\end{lstlisting}
