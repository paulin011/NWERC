\section{Network Flow}

\subsection{Maximum Flow - Edmonds-Karp (BFS-based Ford-Fulkerson)}
\textbf{Description:} Find maximum flow from source to sink. Time: O(VE²).

\begin{lstlisting}
from collections import deque, defaultdict

def max_flow(graph, source, sink, n):
    # graph[u][v] = capacity from u to v
    # Build residual graph
    residual = defaultdict(lambda: defaultdict(int))
    for u in graph:
        for v in graph[u]:
            residual[u][v] = graph[u][v]
    
    def bfs_path():
        # Find augmenting path using BFS
        parent = {source: None}
        visited = {source}
        queue = deque([source])
        
        while queue:
            u = queue.popleft()
            
            if u == sink:
                # Reconstruct path
                path = []
                while parent[u] is not None:
                    path.append((parent[u], u))
                    u = parent[u]
                return path[::-1]
            
            for v in range(n):
                if v not in visited and residual[u][v] > 0:
                    visited.add(v)
                    parent[v] = u
                    queue.append(v)
        
        return None
    
    max_flow_value = 0
    
    # Find augmenting paths
    while True:
        path = bfs_path()
        if path is None:
            break
        
        # Find minimum capacity along path
        flow = min(residual[u][v] for u, v in path)
        
        # Update residual graph
        for u, v in path:
            residual[u][v] -= flow
            residual[v][u] += flow
        
        max_flow_value += flow
    
    return max_flow_value

# Example usage
# graph[u][v] = capacity
graph = defaultdict(lambda: defaultdict(int))
graph[0][1] = 10
graph[0][2] = 10
graph[1][3] = 4
graph[1][4] = 8
graph[2][4] = 9
graph[3][5] = 10
graph[4][3] = 6
graph[4][5] = 10

n = 6  # Number of nodes
result = max_flow(graph, 0, 5, n)
\end{lstlisting}

\subsection{Dinic's Algorithm (Faster)}
\textbf{Description:} Faster max flow using level graph and blocking flow. Time: O(V²E).

\begin{lstlisting}
from collections import deque, defaultdict

class Dinic:
    def __init__(self, n):
        self.n = n
        self.graph = defaultdict(lambda: defaultdict(int))
    
    def add_edge(self, u, v, cap):
        self.graph[u][v] += cap
    
    def bfs(self, source, sink):
        # Build level graph
        level = [-1] * self.n
        level[source] = 0
        queue = deque([source])
        
        while queue:
            u = queue.popleft()
            
            for v in range(self.n):
                if level[v] == -1 and self.graph[u][v] > 0:
                    level[v] = level[u] + 1
                    queue.append(v)
        
        return level if level[sink] != -1 else None
    
    def dfs(self, u, sink, pushed, level, start):
        if u == sink:
            return pushed
        
        while start[u] < self.n:
            v = start[u]
            
            if (level[v] == level[u] + 1 and 
                self.graph[u][v] > 0):
                
                flow = self.dfs(v, sink, 
                               min(pushed, self.graph[u][v]),
                               level, start)
                
                if flow > 0:
                    self.graph[u][v] -= flow
                    self.graph[v][u] += flow
                    return flow
            
            start[u] += 1
        
        return 0
    
    def max_flow(self, source, sink):
        flow = 0
        
        while True:
            level = self.bfs(source, sink)
            if level is None:
                break
            
            start = [0] * self.n
            
            while True:
                pushed = self.dfs(source, sink, float('inf'),
                                 level, start)
                if pushed == 0:
                    break
                flow += pushed
        
        return flow
\end{lstlisting}

\subsection{Min Cut}
\textbf{Description:} Find minimum cut after computing max flow.

\begin{lstlisting}
def min_cut(graph, source, n, residual):
    # After running max_flow, residual graph is available
    # Min cut = set of reachable nodes from source
    visited = [False] * n
    queue = deque([source])
    visited[source] = True
    
    while queue:
        u = queue.popleft()
        for v in range(n):
            if not visited[v] and residual[u][v] > 0:
                visited[v] = True
                queue.append(v)
    
    # Cut edges
    cut_edges = []
    for u in range(n):
        if visited[u]:
            for v in range(n):
                if not visited[v] and graph[u][v] > 0:
                    cut_edges.append((u, v))
    
    return cut_edges
\end{lstlisting}

\subsection{Bipartite Matching}
\textbf{Description:} Maximum matching in bipartite graph using flow.

\begin{lstlisting}
def max_bipartite_matching(left_size, right_size, edges):
    # edges = [(left_node, right_node), ...]
    # Add source (0) and sink (left_size + right_size + 1)
    
    n = left_size + right_size + 2
    source = 0
    sink = n - 1
    
    graph = defaultdict(lambda: defaultdict(int))
    
    # Source to left nodes
    for i in range(1, left_size + 1):
        graph[source][i] = 1
    
    # Left to right edges
    for l, r in edges:
        graph[l + 1][left_size + r + 1] = 1
    
    # Right nodes to sink
    for i in range(1, right_size + 1):
        graph[left_size + i][sink] = 1
    
    return max_flow(graph, source, sink, n)
\end{lstlisting}
