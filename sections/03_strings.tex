\section{String Operations}

\textbf{Description:} Strings in Python are immutable. For building strings, use list and join for O(n) complexity instead of repeated concatenation which is O(nÂ²).

\begin{lstlisting}
# Common string methods
s.lower(), s.upper()
s.strip()   # remove whitespace both ends
s.lstrip()  # remove left whitespace
s.rstrip()  # remove right whitespace
s.split(delimiter)
delimiter.join(list)
s.replace(old, new)
s.startswith(prefix)
s.endswith(suffix)
s.isdigit(), s.isalpha(), s.isalnum()

# String building - EFFICIENT O(n)
result = []
for x in data:
    result.append(str(x))
s = ''.join(result)

# String concatenation - SLOW O(n^2)
# s = ""
# for x in data:
#     s += str(x)  # Don't do this!

# ASCII values
ord('a')  # 97
chr(97)   # 'a'

# String to character array (for mutations)
chars = list(s)
chars[0] = 'x'
s = ''.join(chars)
\end{lstlisting}

\subsection{KMP Pattern Matching}
\textbf{Description:} Find all occurrences of pattern in text. Time: O(n+m).

\begin{lstlisting}
def kmp_search(text, pattern):
    # Build LPS (Longest Proper Prefix which is Suffix)
    def build_lps(pattern):
        m = len(pattern)
        lps = [0] * m
        length = 0  # Length of previous longest prefix
        i = 1
        
        while i < m:
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1
        
        return lps
    
    n, m = len(text), len(pattern)
    lps = build_lps(pattern)
    
    matches = []
    i = j = 0  # Indices for text and pattern
    
    while i < n:
        if text[i] == pattern[j]:
            i += 1
            j += 1
        
        if j == m:
            matches.append(i - j)
            j = lps[j - 1]
        elif i < n and text[i] != pattern[j]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    
    return matches
\end{lstlisting}

\subsection{Z-Algorithm}
\textbf{Description:} Compute Z-array where Z[i] = length of longest substring starting from i that matches prefix. Time: O(n).

\begin{lstlisting}
def z_algorithm(s):
    n = len(s)
    z = [0] * n
    l, r = 0, 0
    
    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    
    return z

# Pattern matching using Z-algorithm
def z_search(text, pattern):
    # Concatenate pattern + $ + text
    s = pattern + '$' + text
    z = z_algorithm(s)
    
    matches = []
    m = len(pattern)
    
    for i in range(m + 1, len(s)):
        if z[i] == m:
            matches.append(i - m - 1)
    
    return matches
\end{lstlisting}

\subsection{Rabin-Karp (Rolling Hash)}
\textbf{Description:} Fast pattern matching using hashing. Average: O(n+m), Worst: O(nm).

\begin{lstlisting}
def rabin_karp(text, pattern):
    MOD = 10**9 + 7
    BASE = 31  # Prime base for hashing
    
    n, m = len(text), len(pattern)
    if m > n:
        return []
    
    # Compute hash of pattern
    pattern_hash = 0
    power = 1
    for i in range(m):
        pattern_hash = (pattern_hash * BASE + 
                       ord(pattern[i])) % MOD
        if i < m - 1:
            power = (power * BASE) % MOD
    
    # Rolling hash
    text_hash = 0
    matches = []
    
    for i in range(n):
        # Add new character
        text_hash = (text_hash * BASE + 
                    ord(text[i])) % MOD
        
        # Remove old character if window full
        if i >= m:
            text_hash = (text_hash - 
                        ord(text[i - m]) * power) % MOD
            text_hash = (text_hash + MOD) % MOD
        
        # Check match
        if i >= m - 1 and text_hash == pattern_hash:
            # Verify actual match (avoid hash collision)
            if text[i - m + 1:i + 1] == pattern:
                matches.append(i - m + 1)
    
    return matches
\end{lstlisting}
